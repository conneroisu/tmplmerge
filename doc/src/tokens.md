# tokens

<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# tokens

```go
import "github.com/conneroisu/gohard/internal/vhdl/tokens"
```

Package tokens provides a list of VHDL tokens.

## Index

- [Variables](<#variables>)
- [type TokenType](<#TokenType>)
  - [func \(typ TokenType\) MarshalJSON\(\) \(\[\]byte, error\)](<#TokenType.MarshalJSON>)
  - [func \(i TokenType\) String\(\) string](<#TokenType.String>)


## Variables

<a name="TokenKey"></a>TokenKey is a map of token names to token types.

```go
var TokenKey = map[string]TokenType{

    "PACKAGE":      Package,
    "ARCHITECTURE": Architecture,
    "ENTITY":       Entity,

    "RISING_EDGE":  RisingEdge,
    "FALLING_EDGE": FallingEdge,

    "GENERIC":  Generic,
    "FUNCTION": Function,

    "BODY":       Body,
    "BLOCK":      Block,
    "ATTRIBUTE":  Attribute,
    "ALL":        All,
    "ALIAS":      Alias,
    "AFTER":      After,
    "ABS":        Abs,
    "BIT":        Bit,
    "BITVECTOR":  BitVector,
    "TRUE":       True,
    "FALSE":      False,
    "INTEGER":    Integer,
    "REAL":       Real,
    "RANGE":      TypeRangeOp,
    "TIME":       Time,
    "CHAR":       TypeChar,
    "STRING":     String,
    "WITH":       With,
    "XNOR":       XNor,
    "UNTIL":      Until,
    "UNITS":      Units,
    "UNAFFECTED": Unaffected,
    "WHILE":      While,
    "WAIT":       Wait,
    "IN":         In,
    "CASE":       Case,
    "COMPONENT":  Component,
    "PROCESS":    Process,
    "POSTPONED":  Postponed,
    "OUT":        Out,
    "OPEN":       Open,
    "ON":         On,
    "OTHERS":     Others,
    "PROCEDURE":  Procedure,
    "DOWNTO":     Downto,
    "FOR":        For,
    "VARIABLE":   Variable,
    "END":        End,
    "WHEN":       When,
    "TO":         To,
    "ELSIF":      Elsif,
    "ASSERT":     Assert,
    "USE":        Use,
    "LEFTPAREN":  LeftParen,
    "RIGHTPAREN": RightParen,
    "IS":         Is,
    "OF":         Of,
    "NULL":       Null,
    "TYPE":       Type,
    "TRANSPORT":  Transport,
    "CONSTANT":   Constant,
    "OR":         Or,
    "XOR":        Xor,
    "AND":        And,
    "PORT":       Port,
    "LIBRARY":    Library,
    "COLON":      Colon,
    "ASSIGN":     Assign,
    "SIGNAL":     Signal,
    "BEGIN":      Begin,
    "SUBTYPE":    Subtype,
    "IMPURE":     Impure,
    "PURE":       Pure,
    ";":          SCol,
    ".":          Dot,

    "SRL": Srl,
    "SRA": Sra,
    "SLL": Sll,
    "SLR": Slr,
    "ROL": Rol,
    "ROR": Ror,

    "REM":           Rem,
    "RETURN":        Return,
    "REJECT":        Reject,
    "REGISTER":      Register,
    "RECORD":        Record,
    "REPORT":        Report,
    "SHARED":        Shared,
    "SELECT":        Select,
    "SEVERITY":      Severity,
    "THEN":          Then,
    "COMMA":         Comma,
    "IF":            If,
    "ARRAY":         Array,
    "ELSE":          Else,
    "NOT":           Not,
    "NOR":           Nor,
    "NEW":           New,
    "NEXT":          Next,
    "NAND":          Nand,
    "MOD":           Mod,
    "MAP":           Map,
    "LOOP":          Loop,
    "LITERAL":       Literal,
    "LINKAGE":       Linkage,
    "LABEL":         Label,
    "INOUT":         InOut,
    "INERTIAL":      Inertial,
    "GUARDED":       Guarded,
    "GROUP":         Group,
    "GENERATE":      Generate,
    "FILE":          File,
    "EXIT":          Exit,
    "DISCONNECT":    Disconnect,
    "CONFIGURATION": Configuration,
    "BUS":           Bus,
    "BUFFER":        Buffer,
}
```

<a name="TokenType"></a>
## type [TokenType](<https://github.com/conneroisu/gohard/blob/main/internal/vhdl/tokens/tokens.go#L7>)

TokenType is a type of token. int

```go
type TokenType int
```

<a name="Body"></a>

```go
const (
    // Body is the body token used to declare a body in VHDL.
    Body TokenType = iota
    // Block is the block token used to declare a block in VHDL.
    Block
    // Attribute is the attribute token associated with a declaration of an
    // attribute in VHDL.
    Attribute
    // Abs is the builtin absolute value token used for calculating the
    // absolute value of a number in VHDL.
    // In VHDL, the `abs` keyword is used as a built-in mathematical function to calculate the absolute value of a numeric expression. It returns the positive magnitude of a number, regardless of whether the original value is positive or negative.
    //
    // The `abs` function can be used with various numeric types in VHDL, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := -5;
    // 	variable int_result : integer;
    // 	int_result := abs(int_a);  -- int_result becomes 5
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := -7.5;
    // 	variable real_result : real;
    // 	real_result := abs(real_a);  -- real_result becomes 7.5
    //
    // 	-- In conditional statements
    // 	if abs(signal_a - signal_b) < threshold then
    // 	  -- Do something when the absolute difference is less than threshold
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= abs(input_signal);
    // 	```
    Abs
    // Entity is the entity token used to declare an entity in VHDL.
    //
    // Example:
    //	```vhdl
    //	entity myentity is
    //		port (
    //			a : in bit;
    //			b : out bit
    //		);
    //	end myentity;
    //	```
    Entity
    // Architecture is the architecture token used to declare an
    // architecture in
    // VHDL.
    //
    // Example:
    //	```vhdl
    //	entity myentity is
    //		port (
    //			c : bit
    //		);
    //	end myentity;
    //
    //	architecture myarch of myentity is
    //	begin
    //		c <= '0';
    //	end myarch;
    //	```
    Architecture
    // End is the end token.
    //
    // Example:
    //	```vhdl
    //	entity my_mux is
    //		port (
    //			Sel: in std_logic_vector (0 to 1);
    //			A, B, C, D: in std_logic_vector (0 to 3);
    //			Y: out std_logic_vector (0 to 3)
    //			);
    //	end my_mux;
    //	architecture mux1 of my_mux is
    //	begin
    //		Y <= A when Sel = "00" else
    //		B when Sel = "01" else
    //		C when Sel = "10" else
    //		D when others;
    //	end mux1;
    //	```
    End
    // EndIf is the end of an if statement.
    //
    // Example:
    //	```vhdl
    //	if (A = B) then
    //		Z <= A;
    //	elsif (A = C) then
    //		Z <= B;
    //	else
    //		Z <= C;
    //	end if;
    //	```
    EndIf
    // LineComment is a line comment in vhdl.
    //
    // Example:
    //	```vhdl
    //	-- This is a comment
    //	```
    LineComment
    // MultiLineComment is a multi-line comment in vhdl.
    //
    // Example:
    //	```vhdl
    //	/*
    //	This is a multi-line comment
    //	*/
    //	```
    MultiLineComment
    // Package is a package declaration.
    Package
    // Identifier is the identifier token.
    //
    // Example (myentity):
    //	```vhdl
    //	entity myentity is
    //		port (
    //			a : in bit;
    //			b : out bit
    //		);
    //	end myentity;
    //	```
    Identifier
    // Component is the component token.
    //
    // Example:
    //	```vhdl
    //	entity myentity is
    //		port (
    //			a : in bit;
    //			b : out bit
    //		);
    //	end myentity;
    //
    //	architecture myarch of myentity is
    //		component mycomponent is
    //			port (
    //				c : in bit;
    //				d : out bit
    //			);
    //		end component;
    //	begin
    //		mycomponent_inst: mycomponent
    //		port map (
    //			c => a,
    //			d => b
    //		);
    //	end myarch;
    //	```
    Component
    // Bit is a token used to represent a bit declared in VHDL.
    //
    // Example:
    //	```vhdl
    //	Q <= '1';
    //	signal b : bit := '0';
    //	```
    Bit
    // BitVector is a token used to represent a bit_vector declared in VHDL.
    //
    // Example:
    //	```vhdl
    //	DataOut <= “00010101”;
    //	```
    BitVector
    // True is a token used to represent a true boolean declared in VHDL.
    //
    // Example:
    //	```vhdl
    //	EQ <= True;
    //	```
    True
    // False is a token used to represent a false boolean declared in VHDL.
    //
    // Example:
    //	```vhdl
    //	EQ <= False;
    //	```
    False
    // Integer is a token used to represent an integer declared in VHDL.
    //
    // ..., -2, -1, 0, 1, 2, 3, 4 ...
    //
    // Example:
    //	```vhdl
    //	c <= c + 10;
    //	```
    Integer
    // Real is a token used to represent a real declared in VHDL.
    //
    // ..., -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0 ...
    //
    // Example:
    //	```vhdl
    //	c <= c + 10.3;
    //	```
    Real
    // TypeRangeOp is the range operator token used to declare a range in VHDL.
    //
    // Example:
    //	```vhdl
    //	type ByteArray is array (0..7) of std_logic;
    //	```
    TypeRangeOp
    // Time is the time token used to declare a time in VHDL.
    //
    // 1 us, 7 ns, 100 ps
    //
    // Example:
    //	```vhdl
    //	c <= 1 after 10 ns;
    //	```
    Time
    // TypeChar is a token used to represent a character declared in VHDL.
    //
    // 'a', 'b', '2, '$', etc.
    //
    // Example:
    //	```vhdl
    //	c <= 'a';
    //	```
    TypeChar
    // String is a token used to represent a string declared in VHDL.
    //
    // "a", "b", "2", "$", etc.
    //
    // Example:
    //	```vhdl
    //	c <= "DEADBEEF";
    //	```
    String
    // With is the with keyword used in VHDL.
    //
    // Example:
    //	```vhdl
    //	architecture concurrent of mux is
    // 	begin
    //		with Sel select
    //			Y <= A when "00",
    //			B when "01",
    //			C when "10",
    //			'X' when others;
    // 	end concurrent;
    //	```
    With
    // XNor is the xnor keyword used in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a XNOR b;
    //	```
    XNor
    // Until is the until keyword used in VHDL.
    //
    // Example:
    //	```vhdl
    //	process begin
    // 	wait until Clk = '1' and Clk'event;
    // 		M_out <= data_in;
    // 	wait until Clk = '1' and Clk'event;
    // 		M_out <= not data_in;
    // 	end process;
    //	```
    Until
    // Units is the units keyword used in VHDL.
    //
    // Example:
    //	```vhdl
    //	type time is range -2_147_483_647 to 2_147_483_647
    // 		units
    // 			fs;
    // 			ps = 1000 fs;
    // 			ns = 1000 ps;
    // 			us = 1000 ns;
    // 			ms = 1000 us;
    // 			sec = 1000 ms;
    // 			min = 60 sec;
    // 			hr = 60 min;
    // 		end units;
    //	```
    Units
    // Unaffected is the unaffected keyword used in VHDL.
    //
    // The unaffected keyword is used to indicate in a conditional or selected
    // signal assignment when the signal is not to be given a
    // new value.
    //
    // Example:
    //	```vhdl
    //	Mux <= A when Sel = "00" else
    //		B when Sel = "01" else
    //		C when Sel = "10" else
    //		unaffected;
    //	```
    Unaffected
    // While is the while keyword used to declare a while loop in VHDL.
    //
    // Example:
    //	```vhdl
    //	while (a = b) loop
    //		c <= '0';
    //	end loop;
    //	```
    While
    // Wait is the wait token.
    // It is used to wait for a time in VHDL.
    //
    // Example:
    //	```vhdl
    //	wait for 10 ns;
    //	```
    Wait
    // In is the in token used to declare a port in VHDL.
    //
    // Example:
    //	```vhdl
    //	entity myentity is
    //		port (
    //			a : in bit;
    //			b : out bit
    //		);
    //	end myentity;
    //	```
    In
    // Case is the case token.
    // It is used to declare a case statement in VHDL.
    //
    // Example:
    //	```vhdl
    //	case a is
    //		when '0' =>
    //			c <= '0';
    //		when '1' =>
    //			c <= '1';
    //	end case;
    //	```
    Case
    // Process is the process token used to declare a process in VHDL.
    //
    // Example:
    //	```vhdl
    //	process (a, b)
    //	begin
    //		if a = '0' then
    //			c <= '0';
    //		elsif a = '1' then
    //			c <= '1';
    //		end if;
    //	end process;
    //	```
    Process
    // Postponed is the postponed keyword used in VHDL.
    //
    // The postponed keyword is used to declare a postponed procedure.
    // Postponed
    // procedures are similar to procedures, but they are
    // executed at a later time.
    //
    // Example:
    //	```vhdl
    //	postponed procedure my_procedure (a, b : in bit) is
    //	begin
    //		if a = '0' then
    //			c <= '0';
    //		elsif a = '1' then
    //			c <= '1';
    //		end if;
    //	end my_procedure;
    //	```
    Postponed
    // On is the on keyword used in VHDL.
    //
    // The on keyword is used as part of a wait statement to temporarily suspend
    // a process until an event occurs which affects one or more specified
    // signals. The process will resume when any or all of the listed signals
    // change.	//
    //
    // Example:
    //	```vhdl
    //	process (a, b)
    // 	begin
    // 		if a = '0' then
    // 			c <= '0';
    // 		elsif a = '1' then
    // 			c <= '1';
    // 		end if;
    // 	end process;
    //	```
    On
    // Others is the others keyword used in VHDL.
    //
    // The others keyword is used to specify a default value for a range of
    // choices in a select statement.
    //
    // Example:
    //	```vhdl
    //	architecture concurrent of mux is
    // 	begin
    // 		with Sel select
    // 			Y <= A when "00",
    // 			B when "01",
    // 			C when "10",
    // 			'X' when others;
    // 	end concurrent;
    //	```
    Others
    // Procedure is the procedure keyword used in VHDL.
    //
    // The procedure keyword is used to declare a procedure.
    // Procedures are similar to functions, but they do not return a value.
    //
    // Example:
    //	```vhdl
    //	procedure my_procedure (a, b : in bit) is
    //	begin
    //		if a = '0' then
    //			c <= '0';
    //		elsif a = '1' then
    //			c <= '1';
    //		end if;
    //	end my_procedure;
    //	```
    Procedure
    // Downto is the downto token used to declare a range in VHDL.
    //
    // Example:
    //	```vhdl
    //	library IEEE;
    // 	use IEEE.std_logic_1164.all;
    //
    //	entity counter is
    //		port (
    //			clk : in std_logic;
    //			reset : in std_logic;
    //			count : out std_logic_vector(3 downto 0);
    //		);
    //	end counter;
    //	```
    Downto
    // For is the for token used to declare a port in VHDL.
    //
    // Example:
    //	```vhdl
    //	entity parity10 is
    //
    //		port(
    //			D: in array(0 to 9) of bit;
    //			ODD: out bit
    //		);
    //		constant WIDTH: integer := 10;
    //
    // 	end parity10;
    // 	architecture behavior of parity10 is
    //		begin
    // 		process(D)
    // 		variable otmp: Boolean;
    // 		begin
    // 		otmp := false;
    // 		for i in 0 to D'length - 1 loop
    //			if D(i) = '1' then
    //				otmp := not otmp;
    // 			end if;
    // 		end loop;
    //		if otmp then
    // 			ODD <= '1';
    //		else
    //			ODD <= '0';
    //		end if;
    // 		end process;
    // 	end behavior;
    //	```
    For
    // Range is the range token used to declare a range in VHDL.
    //
    // Example:
    //	```vhdl
    //	type state_type is (Init, Hold, Strobe, Read, Idle);
    //	subtype reverse_state_type is state_type range Idle downto Init;
    //	```
    Range
    // Variable is the variable token used to declare a variable in VHDL.
    //
    // Example:
    //	```vhdl
    //	process(Rst,Clk)
    // 	variable Q: integer range 0 to 15;
    // 	begin
    // 		if Rst = '1' then
    // 		-- Asynchronous reset
    // 			Q := 0;
    // 		elsif rising_edge(Clk) then
    // 			if Load = '1' then
    // 				Q := to_unsigned(Data);
    // 			-- Convert vector to integer
    // 			elsif Q = 15 then
    // 			Q := 0;
    // 			else
    // 			Q := Q + 1;
    // 			end if;
    // 		end if;
    // 		Count <= to_vector(4,Q); -- Convert integer to
    // 		-- vector
    // 	end process;
    //	```
    Variable
    // When is the when token.
    //
    // Example:
    //	```vhdl
    //	entity my_mux is
    // 		port (
    // 			Sel: in std_logic_vector (0 to 1);
    // 			A, B, C, D: in std_logic_vector (0 to 3);
    // 			Y: out std_logic_vector (0 to 3)
    // 			);
    // 	end my_mux;
    // 	architecture mux1 of my_mux is
    // 	begin
    // 		Y <= A when Sel = "00" else
    // 		B when Sel = "01" else
    // 		C when Sel = "10" else
    // 		D when others;
    // 	end mux1;
    //	```
    When
    // To is the to token used to declare a range in VHDL.
    // It is similar to the range operator in VHDL.
    //
    // Example:
    //	```vhdl
    //	entity my_mux is
    //
    // 	port (
    // 		Sel: in std_logic_vector (0 to 1);
    // 		A, B, C, D: in std_logic_vector (0 to 3);
    // 		Y: out std_logic_vector (0 to 3)
    // 		);
    //
    // 	end my_mux;
    // 	architecture mux1 of my_mux is
    // 	begin
    // 		Y <= A when Sel = "00" else
    // 		B when Sel = "01" else
    // 		C when Sel = "10" else
    // 		D when others;
    // 	end mux1;
    //	```
    To
    // Elsif is the elsif token.
    //
    // Example:
    //	```vhdl
    //	library IEEE;
    // 	use IEEE.std_logic_1164.all;
    //
    // 	entity ElsifExample is
    // 	    Port (
    // 	        sel    : in  std_logic_vector(1 downto 0);
    // 	        data0  : in  std_logic;
    // 	        data1  : in  std_logic;
    // 	        data2  : in  std_logic;
    // 	        result : out std_logic
    // 	    );
    // 	end ElsifExample;
    //
    // 	architecture rtl of ElsifExample is
    // 	begin
    // 	    process(sel, data0, data1, data2)
    // 	    begin
    // 	        if sel = "00" then
    // 	            result <= data0;
    // 	        elsif sel = "01" then
    // 	            result <= data1;
    // 	        elsif sel = "10" then
    // 	            result <= data2;
    // 	        else
    // 	            result <= '0';
    // 	        end if;
    // 	    end process;
    // 	end rtl;
    //	```
    Elsif
    // Assert is the assert token.
    // It is used to assert a condition in VHDL.
    //
    // Example:
    //	```vhdl
    //	library IEEE;
    // 	use IEEE.std_logic_1164.all;
    //
    // 	entity AssertExample is
    // 	end AssertExample;
    //
    // 	architecture Behavioral of AssertExample is
    // 	    signal clk : std_logic := '0';
    // 	begin
    // 	    clk_gen: process
    // 	    begin
    // 	        clk <= not clk;
    // 	        wait for 5 ns;
    // 	    end process clk_gen;
    // 	    check_condition: process(clk)
    // 	        variable counter : integer := 0;
    // 	    begin
    // 	        if rising_edge(clk) then
    // 	            counter := counter + 1;
    // 	            assert counter <= 10
    // 	                report "Counter exceeded 10!"
    // 	                severity error;
    // 	            if counter = 12 then
    // 	                wait;
    // 	            end if;
    // 	        end if;
    // 	    end process check_condition;
    // 	end Behavioral;
    //	```
    Assert
    // Use is the use token used to import from a library in VHDL.
    //
    // Example:
    //	```vhdl
    //	use ieee.std_logic_1164.all;
    //	```
    Use
    // LeftParen is the left parenthesis token.
    //
    // Example: `(`
    //	```vhdl
    //	type mytype is array (0 to 10) of bit;
    //	```
    LeftParen
    // RightParen is the right parenthesis token.
    //
    // Example: `)`
    //	```vhdl
    //	type mytype is array (0 to 10) of bit;
    //	```
    RightParen
    // Is is the is token used to declare types in VHDL.
    //
    // Example:
    //	```vhdl
    //	type mytype is array (0 to 10) of bit;
    //	```
    Is
    // Of is the of token used to declare an array in VHDL.
    //
    // Example:
    //	```vhdl
    //	type mytype is array (0 to 10) of bit;
    //	```
    Of
    // Null is the null keyword used in VHDL.
    //
    // The null keyword is used to declare a null statement. A null statement is
    // a statement that does nothing.
    //
    // Example:
    //	```vhdl
    //	null;
    //	```
    Null
    // Type is the type token used to declare a type in VHDL.
    //
    // Example:
    //	```vhdl
    //	type mytype is array (0 to 10) of bit;
    //	```
    Type
    // Transport is the transport keyword used in VHDL.
    //
    // The transport keyword is used to specify non-inertial delay in a
    // signal assignment statement.
    //
    // Example:
    //	```vhdl
    //	Waveform <= transport '1' after 10 ns;
    //	```
    Transport
    // Constant is the constant token used to declare a constant in VHDL.
    //
    // Example:
    //	```vhdl
    //	constant SRAM: bit_vector(15 downto 0) := X"F0F0";
    //	```
    Constant
    // Or is the or keyword used in VHDL.
    //
    // The or operator is a logical operator that can be applied to bit types.
    // The result of the expression “A or B” is a bit type and
    // is defined to be “1” if either A or B is “1”, and “0” otherwise.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a or b;
    //	```
    Or
    // Xor is the xor token in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a XOR b;
    //	```
    Xor
    // And is the and token in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a And b;
    //	```
    And
    // Port is the port token.
    //
    // Example:
    //	```vhdl
    //	entity myentity is
    //		port (
    //			a : in bit;
    //			b : out bit
    //		);
    //	end myentity;
    //	```
    Port
    // Library is the library token used to declare a library in VHDL.
    //
    // Example:
    //	```vhdl
    //	library ieee;
    //	```
    Library
    // Colon is the colon token.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a XOR b;
    //	```
    Colon
    // Assign is the colon and equals token used to declare a process in
    // VHDL.
    // It assigns the value(s) on its right to the variable on its left.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a XOR b;
    //	```
    Assign
    // Signal is the signal token.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a XOR b;
    //	```
    Signal
    // Begin is the begin token used to declare a process in VHDL.
    //
    // Example:
    //	```vhdl
    //	process (a, b)
    //	begin
    //		if a = '0' then
    //			c <= '0';
    //		elsif a = '1' then
    //			c <= '1';
    //		end if;
    //	end process;
    //	```
    Begin
    // SCol is the semicolon token.
    //
    // Example:
    //	```vhdl
    //	process (a, b)
    //	begin
    //		if a = '0' then
    //			c <= '0';
    //		elsif a = '1' then
    //			c <= '1';
    //		end if;
    //	end process;
    //	```
    SCol
    // Subtype is the subtype keyword used in VHDL.
    //
    // The subtype keyword declares a subtype (a type with a constraint that is
    // based on an existing parent type).
    //
    // A subtype declaration includes – in this order – the reserved word
    // “subtype”, the subtype's identifier, the reserved word “is”, an
    // optional resolution function, the base type of the subtype, and an
    // optional constraint. If no constraint is included, the subtype is
    // the same as the specified base type
    //
    // Example:
    //	```vhdl
    //	subtype short is integer range 0 to 255;
    //	subtype X01Z is std_ulogic range 'X' to 'Z';
    //	```
    Subtype
    // Srl is the srl keyword used in VHDL.
    //
    // Example:
    //	```vhdl
    //	Addr <= Addr srl 8;
    //	```
    Srl
    // Impure is the impure keyword used in VHDL.
    //
    // The impure keyword is used to declare an impure function. Impure
    // functions may have side effects, and may return different values
    // for a given set of input actual parameters.
    //
    // Example:
    //	```vhdl
    //	impure function HoldCheck (Clk, Data) return Boolean;
    //	```
    Impure
    // Pure is the pure keyword used in VHDL.
    //
    // The pure keyword is used to declare a pure function. Pure functions
    // always return the same value for a given set of input actual
    // parameters, and have no side effects.
    // Pure is assumed if there is no pure or impure keyword.
    //
    // Example:
    //	```vhdl
    //	pure function HoldCheck (Clk, Data) return Boolean;
    //	```
    Pure
    // Sra is the shift right arithmetic operator token used in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a SRA b;
    //	```
    Sra
    // Sll is the shift left logical operator token used in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a SLL b;
    //	```
    Sll
    // Slr is the shift right logical operator token used in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a SLR b;
    //	```
    Slr
    // Rol is the rotate left operator token used in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a ROL b;
    //	```
    Rol
    // Ror is the rotate right operator token used in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a ROR b;
    //	```
    Ror
    // Return is the return token used in VHDL.
    //
    // Example:
    //	```vhdl
    //	function my_function (a, b : in bit) return bit is
    // 	begin
    // 		if a = '0' then
    // 			return '0';
    // 		elsif a = '1' then
    // 			return '1';
    // 		end if;
    // 	end my_function;
    //	```
    Return
    // Reject is the reject keyword used in VHDL.
    //
    // The reject keyword is used to specify the minimum pulse width to
    // propagate as a result of an after clause. If no reject time is specified,
    // the specified delay time is assumed for the reject time.
    //
    // Example:
    //	```vhdl
    // 	Q <= Data reject 2 ns after 7 ns; -- Delay is 7 ns, reject time is 2 ns
    //	```
    Reject
    // Register is the register keyword used in VHDL.
    //
    // Register is one of two kinds of signals used in a signal declaration
    // (the
    // other is bus). A register signal represents a hardware storage register
    // and defaults to its last driven value when all of the signal's drivers
    // are
    // turned off.
    //
    // Example:
    //	```vhdl
    //	signal storage_state : resolve_state state_type register := state_one;
    //	```
    Register
    // Record is the record keyword used in VHDL.
    //
    // The record keyword is used to declare a record type and its corresponding
    // element types.
    // A record statement includes – in this order – the following:
    // - the reserved word “record”,
    // - an element declaration which includes – in this order – one or more
    // identifiers which share a common subtype, followed by
    // identification of that subtype,
    // - optionally, additional element declarations of the form specified
    // above, and
    // - the reserved words “end record”.
    // An element declaration that includes more than one identifier (for
    // example, “COUNT, SUM, TOTAL: INTEGER”) is equivalent
    // to a series of single element declarations.
    //
    // Example:
    //	```vhdl
    //	type test_record is record
    // 		CE: std_ulogic;
    // 		-- Clock enable
    // 		Set: std_ulogic;
    // 		Din: std_ulogic;
    // 		CRC_Sum: std_ulogic_vector (15 downto 0);
    // 		end record;
    // 	type test_array is array(positive range <>) of test_record;
    //	```
    Record
    // Rem is the rem keyword used in VHDL.
    //
    // The rem operator is a remainder operator that can be applied to integer
    // types. The result of the expression “A rem B” is an
    // integer type and is defined to be the value such that:
    // - the sign of (A rem B) is the same as the sign of A, and
    // - abs (A rem B) < abs (B), and
    // - (A rem B) = (A - (A / B) * B).
    //
    // Example:
    //	```vhdl
    //	begin
    // 		for i in 0 to (bits-1) loop
    // 			if ((tmp rem 2) = 1) then
    // 				out_vec(i) := '1';
    // 			end if;
    // 			tmp := tmp/2;
    // 		end loop;
    // 		return out_vec;
    // 	end int_2_v;
    //	```
    Rem
    // Report is the report keyword used in VHDL.
    // The report keyword is an option that can be defined as part of an assert
    // statement. It allows a user-defined message to be
    // displayed if the given condition of the statement is false.
    //
    // Example:
    // ```vhdl
    //	assert (S = S_expected)
    // 	report "S does not match the expected value!"
    // 	severity Error;
    // ```
    Report
    // Shared is the shared keyword used in VHDL.
    // The shared keyword is used as part of a variable declaration to allow the
    // variable to be accessed by multiple processes.
    //
    // Example:
    //	```vhdl
    //	architecture example of test1 is
    // 	shared variable base_time : natural := 0;
    // 		...
    // 		begin
    // 		...
    // 	end example;
    //	```
    Shared
    // Select is the select keyword used in VHDL.
    //
    // Select is a concurrent signal assignment statement that selects and
    // assigns a value to a target signal from among a list of
    // alternatives, based on the value of a given expression.
    //
    // A select statement includes – in this order – the following:
    //	- the reserved word “with”, followed by the expression to be
    //		evaluated, followed by the reserved word “select”,
    //	- the target signal, followed by the reserved symbol “<=“,
    //		followed by:
    //		(a) the first value which could be assigned to the
    //			target signal, followed by the reserved word
    //			“when”, followed by a choice which, if the
    //			expression evaluates to be that choice, will
    //			cause the first value to be assigned to the
    //			target signal.
    //		(b) second and subsequent values which could be assigned
    //			to the target signal, each followed by the
    //			reserved word “when”, and each followed by a
    //			choice which, if the expression evaluates to be
    //			that choice, will cause the value to be assigned
    //			to the target signal.
    //
    // Since the select statement chooses one and only one alternative for
    // execution at a given time, all possible values for the expression
    // must be covered in “when” statements.
    //
    // An “others” clause may be used to cover values not explicitly named.
    //
    // Example:
    //	```vhdl
    //	architecture concurrent of mux is
    // 	begin
    // 		with Sel select
    // 			Y <= A when "00",
    // 			B when "01",
    // 			C when "10",
    // 			'X' when others;
    // 	end concurrent;
    //	```
    Select
    // Severity is the severity keyword used in VHDL.
    //
    // The severity keyword is an option that can be defined as part of an
    // assert statement.
    //
    // It allows the user to choose a severity level if the given condition of
    // the statement is false. The four possible severity levels are: Note,
    // Warning, Error, and Failure. The value of severity is typically used to
    // control the actions of a simulation in the event the given condition is
    // false. For example, a severity level of Failure may be used to stop the
    // simulation.
    //
    // Example:
    //	```vhdl
    //	assert A = B
    //		report "A is not equal to B"
    //		severity error;
    //	```
    Severity
    // Then is the then keyword used in VHDL.
    //
    // The then keyword is part of the syntax of an if statement.
    //
    // Example:
    //	```vhdl
    //	if A > B then
    // 		Compare <= GT;
    // 	elsif A < B then
    // 		Compare <= LT;
    // 	else
    // 		Compare <= EQ;
    // 	end if;
    //	```
    Then
    // Comma is the comma token.
    //
    // Example:
    //	```vhdl
    //	entity myentity is
    //		port (
    //			a, b : in bit
    //		);
    //	end myentity;
    //	```
    Comma
    // If is the if token used to declare a process in VHDL.
    //
    // Example:
    //	```vhdl
    //	process (a, b)
    //	begin
    //		if a = '0' then
    //			c <= '0';
    //		elsif a = '1' then
    //			c <= '1';
    //		end if;
    //	end process;
    //	```
    If
    // Array is the array token used to declare an array in VHDL.
    //
    // Example:
    //	```vhdl
    //	library IEEE;
    // 	use IEEE.STD_LOGIC_1164.ALL;
    //
    // 	entity ArrayExample is
    // 	end ArrayExample;
    //
    // 	architecture Behavioral of ArrayExample is
    // 	    -- Define an array type named 'MemoryArray'
    // 	    type MemoryArray is array (0 to 15) of std_logic_vector(7 downto 0);
    // 	    signal memory : MemoryArray;
    // 	begin
    // 	    -- Architecture statements using the 'memory' signal go here.
    // 	end Behavioral;
    //	```
    Array
    // Else is the else token.
    //
    // Example:
    //	```vhdl
    //	process (a, b, c)
    //	begin
    //		if a = '0' then
    //			c <= '0';
    //		else
    //			c <= '1';
    //		end if;
    //	end process;
    //	```
    Else
    // Not is the not token in VHDL.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := NOT (a AND b);
    //	```
    Not
    // Nor is the Nor keyword used in VHDL.
    //
    // The Nor operator is a logical operator that can be applied to bit types.
    // The result of the expression “A Nor B” is a bit type and
    // is defined to be “1” if neither A Nor B is “1”, and “0” otherwise.
    //
    // Example:
    //	```vhdl
    //	signal a : bit := '0';
    //	signal b : bit := '0';
    //	signal c : bit := a Nor b;
    //	```
    Nor
    // New is the new keyword used in VHDL.
    //
    // The new keyword is used to create an object of a specified type and
    // return an access value that refers to the created object. A new statement
    // includes – in this order – the allocator (which, when evaluated,
    // refers to the created object), followed by the reserved symbol “:=“,
    // followed by the reserved word “new”, followed by the type of the
    // object being created, and optionally followed by the reserved “new”
    // and an expression for the initial value of the object being created.
    // Example:
    //	```vhdl
    //	count := new natural;
    //	```
    New
    // Next is the next keyword used in VHDL.
    // Next is a statement allowed within a loop that causes the current
    // iteration of the loop to be terminated and cycles the loop to the
    // beginning of its next iteration.
    // A next statement includes – in this order – the reserved word
    // “next”, an optional loop label (which must be the same as the label
    // of the loop in which the next statement occurs), and, optionally, the
    // reserved word “when” followed by a condition which,
    // when True, causes the next statement to be executed.
    // If a “when” clause is not included, a “next” statement is
    // executed as soon as it is encountered.
    //
    // Example:
    //	```vhdl
    //	L1 : for i in 0 to 9 loop
    // 	     L2 : for j in opcodes loop
    // 		for k in 4 downto 2 loop -- loop label is optional
    // 		if k = i next L2;
    // 		-- go to next L2 loop
    // 		end loop;
    // 		exit L1 when j = crash; -- exit loop L1
    // 		end loop;
    // 	end loop;
    //	```
    Next
    // Nand is a logical “not and” operator token which can be used in an
    // expression.
    //
    // It produces the opposite of the logical negation of the “and” operator.
    // The expression “A nand B” returns True when
    // - A is false, or
    // - B is false, or
    // - both A and B are false.
    // Example:
    //	```vhdl
    //	begin
    // 		Y <= (A nand B) and Sel;
    // 		Y <= (A nor B) and not Sel;
    // 	end;
    //	```
    Nand
    // Mod is the mod operator token used in VHDL.
    //
    // The mod keyword is a modulus operator that can be applied to integer
    // types.
    // The result of the expression “A mod B” is an
    // integer type and is defined to be the value such that:
    // - the sign of (A mod B) is the same as the sign of B, and
    // - abs (A mod B) < abs (B), and
    // - (A mod B) = (A * (B - N)) for some integer N.
    //
    // Example:
    //	```vhdl
    //	begin
    // 	for i in 0 to (bits-1) loop
    //		if ((tmp mod 2) = 1) then
    //			out_vec(i) := '1';
    //		end if;
    //		tmp := tmp/2;
    // 	end loop;
    //	return out_vec;
    // 	end int_2_v;
    //	```
    Mod
    // Map is the map keyword used in VHDL.
    //
    // The map keyword is used in conjunction with the port and generic keywords
    // to declare a port map or generic map respectively.
    //
    // Example:
    //	```vhdl
    // 	     architecture my_arch of my_entity is
    // 		begin
    // 			my_entity_inst: my_entity
    //
    // 			port map (
    // 				a => a,
    // 				b => b
    // 			);
    //
    // 		end my_arch;
    // 	```
    Map
    // Loop is the loop keyword used in VHDL.
    // The loop keyword executes a series of sequential statements multiple
    // times.
    // A loop statement can include either:
    // - a “while” iteration scheme,
    // - a “for” iteration scheme, or
    // - no iteration scheme.
    // A loop statement using a “while” iteration scheme includes – in
    // this order – the following:
    // - an optional loop label,
    // - the reserved word “while”, followed by the condition which controls
    // whether the series of sequential statements within the
    // loop is executed, followed by the reserved word “loop”,
    // - the series of sequential statements to be executed if the test
    // condition evaluates to be True, - the reserved words “end loop”,
    // followed by an optional loop label (which, if used, must be the same as
    // the loop label
    // declared above.
    //
    // Example:
    //	```vhdl
    //	L1 : while (a = b) loop
    //		c <= '0';
    //	end loop;
    //	```
    Loop
    // Literal is the literal keyword used in VHDL.
    //
    // The literal keyword is used in group template declarations.
    //
    // Example:
    //	```vhdl
    //	library ieee;
    // 	use ieee.std_logic_1164.all;
    //
    // 	entity literal_example is
    // 	end literal_example;
    //
    // 	architecture rtl of literal_example is
    // 	  literal MY_LITERAL : integer := 42;
    // 	begin
    // 	  process
    // 	  begin
    // 	    report "The value of MY_LITERAL is " & integer'image(MY_LITERAL);
    // 	    wait;
    // 	  end process;
    // 	end rtl;
    //	```
    Literal
    // Label is a label token used in VHDL.
    //
    // The label keyword is used to specify a label name in an attribute
    // statement.
    //
    // Example:
    //	```vhdl
    //	attribute CHIP_PIN_LC of u0 : label is "LAB2";
    //	attribute CHIP_PIN_LC of u2 : label is "LAB7";
    //	```
    Label
    // Inertial is the inertial keyword used in VHDL.
    //
    // The inertial keyword is used to specify that a delay is inertial. In the
    // absence of an inertial or transport keyword, the delay is
    // assumed to be inertial.
    //
    // Example:
    //
    //	```vhdl
    //	Qout <= A and B inertial after 12 ns;
    //	```
    Inertial
    // Guarded is the guarded keyword used in VHDL.
    //
    // The guarded keyword is used to limit the execution of a signal statement
    // within a block when the block includes a guard
    // statement.
    //
    // Example:
    //	```vhdl
    //	library ieee;
    // 	use ieee.std_logic_1164.all;
    //
    // 	entity GuardedExample is
    // 	  port (
    // 	    clk     : in  std_logic;
    // 	    enable  : in  std_logic;
    // 	    data_in : in  std_logic_vector(7 downto 0);
    // 	    data_out: out std_logic_vector(7 downto 0)
    // 	  );
    // 	end GuardedExample;
    //
    // 	architecture Behavioral of GuardedExample is
    // 	  -- Declare a signal as guarded.
    // 	  -- When a signal is declared as guarded, any assignment to it must
    // occur
    // 	  -- within a block that has a guard clause.
    // 	  signal bus : std_logic_vector(7 downto 0) guarded;
    // 	begin
    //
    // 	  Bus_Drive: block
    // 	    guard enable;
    // 	  begin
    // 	    process(clk)
    // 	    begin
    // 	      if rising_edge(clk) then
    // 	        bus <= data_in;
    // 	      end if;
    // 	    end process;
    // 	  end block Bus_Drive;
    // 	  -- When 'enable' is '0', the Bus_Drive block does not drive 'bus',
    // 	  -- so the value of 'bus' remains unchanged (or follows the rules of
    // its
    // 	  -- resolution function, if multiple drivers exist).
    // 	  data_out <= bus;
    // 	end Behavioral;
    //	```
    Guarded
    // Group is the group token used in VHDL.
    //
    // The group keyword is used to define a group template or specific group.
    // Groups may be used to give a name to a collection of
    // named entities.
    //
    // Group Template Declaration
    // A group template declaration includes – in this order – the reserved
    // word “group” followed by a group name, the reserved word
    // “is”, and a list of classes enclosed in parentheses.
    // Example:
    //	```vhdl
    //	group signal_pair is (signal1, signal2); -- group of two signals
    //	```
    //
    // Group Declaration
    // A group declaration includes – in this order – the reserved word
    // “group” followed by a group name, the character “:”, a group
    // template name, and a list of named entities enclosed in parentheses.
    // Example:
    //	```vhdl
    //	group G1: signal_pair(Clk1,Clk2);
    //	```
    Group
    // Generic is the generic keyword used in VHDL.
    //
    // The generic keyword used in a component or configuration to define
    // constants whose values may be controlled by the
    // environment.
    //
    // A generic statement includes – in this order – the reserved word
    // “generic”, followed by a list of declarations for the generics
    // being defined.
    //
    // Example:
    //	```vhdl
    //	generic(RISE, FALL: time := 0 ns);
    //	```
    Generic
    // Generate is the generate keyword used in VHDL.
    //
    // The generate keyword is used to do one of the following:
    // - replicate a set of concurrent statements (a for-generation), or
    // - selectively execute a set of concurrent statements if a specified
    // condition is met (an if-generation).
    //
    // A generate statement used to replicate a set of concurrent statements
    // includes – in this order – the following: - a label for the generate,
    // followed by the reserved word “for”, followed by a parameter
    // specification for the “for”,
    // - the reserved word “generate”,
    // - the concurrent statements to be replicated,
    // - the reserved words “end generate”.
    //
    // A generate statement used to selectively execute a set of concurrent
    // statements includes – in this order – the following: - a label for
    // the generate, followed by the reserved word “if”, followed by the
    // condition for the “if”,
    // - the reserved word “generate”,
    // - the concurrent statements to be selectively executed if the test
    // condition is true,
    // - the reserved words “end generate”.
    //
    // Example:
    //	```vhdl
    //	G: for I in 0 to (WIDTH - 2) generate
    //		-- This generate statement creates the first
    // 		-- XOR gate in the series...
    // 		G0: if I = 0 generate
    //			X0: xor2 port map(A => D(0), B => D(1), Y => p(0));
    // 		end generate G0;
    // 		-- This generate statement creates the middle
    // 		-- XOR gates in the series...
    // 		G1: if I > 0 and I < (WIDTH - 2) generate
    //			X0: xor2 port map(A => p(i-1), B => D(i+1), Y => p(i));
    // 		end generate G1;
    // 		-- This generate statement creates the last
    // 		-- XOR gate in the series...
    // 		G2: if I = (WIDTH - 2) generate
    //			X0: xor2 port map(A => p(i-1), B => D(i+1), Y => ODD);
    // 		end generate G2;
    // 	end generate G;
    //	```
    Generate
    // Function is a token representing a function.
    // A function statement defines a group of sequential statements that return
    // a single value. A function specification includes – in this order –
    // the reserved word “function”, the function's name, a parameter list
    // (which can only include constants and signal objects, and must all be of
    // mode in), the reserved word “return”, and the type of the value to
    // be returned by the function.
    // Example:
    //	function to_unsigned (a: std_ulogic_vector)
    //		return integer is
    // 		alias av: std_ulogic_vector (1 to a'length) is a;
    // 		variable ret,d: integer;
    // 		begin
    // 		d := 1;
    // 		ret := 0;
    // 		for i in a'length downto 1 loop
    //			if (av(i) = '1') then
    //				ret := ret + d;
    // 			end if;
    //		d := d * 2;
    // 		end loop;
    // 		return ret;
    // 	end to_unsigned;
    Function
    // File is the file keyword used in VHDL.
    //
    // The file keyword declares a file.
    // A file declaration includes – in this order – the reserved word
    // “file”, the name of the file (as used by the program), the subtype
    // indicator (which must define a file subtype), the reserved word “is”,
    // on optional mode indicator (which must be either “in” or “out”),
    // and the file's external name (which must be a string expression and is
    // surrounded by quote marks). If no mode is
    // specified, the default is “in”.
    //
    // Example:
    //	```vhdl
    //	file vector_file: text is in "VECTOR.DAT";
    //	```
    File
    // Exit is the exit token used in VHDL.
    //
    // The exit keyword is a sequential statement used in a loop to cause
    // execution to jump out of the loop. An exit statement can only be used in
    // a loop and can include an optional when condition. An exit statement
    // includes – in this order – the reserved word “exit”, an optional
    // loop identifier (if no identifier is given, the exit statement is applied
    // to the loop in which the exit statement occurs), and, optionally, the
    // reserved word “when” followed by the condition under which the exit
    // action is to be executed.
    //
    // Example:
    //	for idx in vectors'range loop
    // 	     apply_vector(vec(idx));
    // 		wait for PERIOD;
    // 		if done = '1' then
    // 	     	exit;
    // 		end if;
    // 	end loop;
    Exit
    // Disconnect is the disconnect token used in VHDL.
    //
    // The disconnect keyword specifies the time delay to disconnect the guarded
    // feature of a signal which is part of a guarded signal
    // statement.
    // A disconnect statement includes – in this order – the reserved word
    // “disconnect”, the name of the guarded signal, the guarded signal's
    // type, the reserved word “after”, and a time expression specifying the
    // time after which the guard feature should be
    // disconnected.
    // In place of the guarded signal's name, the reserved words “others” or
    // “all” may be used. “Others” refers to all other signal statements
    // in the immediately enclosing declarative region which have not been
    // specified in a separate disconnect statement.
    // “All” refers to all other signal statements in the declarative region.
    //
    // Example:
    //	```vhdl
    //	architecture sample_architecture of test1 is
    // 	signal input_data_bus : resolved_word bus;
    // 	disconnect input_data_bus : resolved_word after 6ns;
    // 	begin
    // 	...
    // 	end sample_architecture;
    //	```
    Disconnect
    // Configuration is the configuration token used in VHDL.
    //
    // A declaration used to create a configuration for an entity.
    // A configuration declaration for a given entity binds one architecture
    // body to the entity and can bind components of architecture bodies within
    // that entity to other entities. In a given configuration declaration for
    // an entity, only one architecture body can be bound to that entity.
    // However, one entity can have many
    // configurations.
    //
    // Example:
    //	```vhdl
    //	configuration this_build of adder is
    // 	use work.all;
    // 	for structure
    //		for A1,A2,A3: AddBlock
    //			use entity FullAdd(behavior);
    //		end for;
    // 	end for;
    // 	end this_build;
    //	```
    Configuration
    // Bus is the bus token used in VHDL.
    //
    // Bus specifies one of two kinds of signals used in a signal
    // declaration
    // (the other is register). A bus signal represents a hardware bus and
    // defaults to a user-specified value when all of the signal's drivers are
    // turned off.
    //
    // Example:
    //	```vhdl
    //	entity tbuf is
    //		port (enable: boolean; a: bundle; m: out bundle bus);
    // 	end tbuf;
    //	```
    Bus
    // Number is a number token.
    //
    // Example (50):
    //	```vhdl
    //	entity tbuf is
    //		generic (gCLK_HPER : time := 50 ns);
    // 	end tbuf;
    //	```
    Number

    // RisingEdge is the rising_edge token used to declare a rising edge
    // event in VHDL.
    //
    // Built-in function rather than a keyword, though it's frequently used as if it were a keyword. It's defined in the IEEE standard library and detects the rising edge (transition from '0' to '1') of a signal.
    //
    // The `rising_edge` function takes a signal of type `std_logic` or `std_ulogic` as its input and returns a boolean value. It returns `true` when the signal transitions from a low level ('0') to a high level ('1') in the current simulation cycle.
    //
    // Example:
    //
    //	```vhdl
    // 	-- First, include the necessary library
    // 	library IEEE;
    // 	use IEEE.std_logic_1164.all;
    //
    // 	-- Then use it in a process
    // 	process(clk)
    // 	begin
    // 	  if rising_edge(clk) then
    // 	    -- Code to execute on the rising edge of clk
    // 	    q <= d; -- For example, a D flip-flop behavior
    // 	  end if;
    // 	end process;
    // 	```
    //
    // This is equivalent to the alternative syntax:
    //
    // Example:
    //
    //	```vhdl
    // 	process(clk)
    // 	begin
    // 	  if (clk'event and clk = '1') then
    // 	    -- Code to execute on the rising edge of clk
    // 	    q <= d;
    // 	  end if;
    // 	end process;
    // 	```
    //
    RisingEdge
    // FallingEdge is the falling_edge token used to declare a falling edge
    // event in VHDL.
    //
    // Built-in function rather than a keyword, though it's frequently used as if it were a keyword. It's defined in the IEEE standard library and detects the falling edge (transition from '1' to '0') of a signal.
    //
    // The `falling_edge` function takes a signal of type `std_logic` or `std_ulogic` as its input and returns a boolean value. It returns `true` when the signal transitions from a high level ('1') to a low level ('0') in the current simulation cycle.
    //
    // Example:
    //
    //	```vhdl
    // 	-- First, include the necessary library
    // 	library IEEE;
    // 	use IEEE.std_logic_1164.all;
    //
    // 	-- Then use it in a process
    // 	process(clk)
    // 	begin
    // 	  if falling_edge(clk) then
    // 	    -- Code to execute on the falling edge of clk
    // 	    q <= d; -- For example, a D flip-flop behavior
    // 	  end if;
    // 	end process;
    // 	```
    //
    // This is equivalent to the alternative syntax:
    //
    // Example:
    //
    //	```vhdl
    // 	process(clk)
    // 	begin
    // 	  if (clk'event and clk = '0') then
    // 	    -- Code to execute on the falling edge of clk
    // 	    q <= d;
    // 	  end if;
    // 	end process;
    // 	```
    //
    FallingEdge

    // Illegal is the illegal token used to declare an illegal token.
    Illegal

    // Tick is the tick token used to declare a tick token in VHDL.
    //
    // The `'` operator is used to perform a tick operation in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : integer;
    // 	int_result := int_a 'tick int_b;  -- int_result becomes 8
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : real;
    // 	real_result := real_a 'tick real_b;  -- real_result becomes 6.2
    //
    // 	-- In conditional statements
    // 	if int_a 'tick int_b > threshold then
    // 	  -- Do something when the sum is greater than threshold
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a 'tick int_b;
    // 	```
    Tick // '
    // Arrow is the arrow token used to declare an arrow operator in VHDL.
    //
    // The `=>` operator is used to specify the direction of a signal assignment in VHDL. It is used to connect a signal to another signal or a variable.
    //
    // Example:
    //
    //	```vhdl
    //	signal a : integer := 0;
    //	signal b : integer := 0;
    //	signal c : integer := 0;
    //	signal d : integer := 0;
    //	signal e : integer := 0;
    //	signal f : integer := 0;
    //	signal g : integer := 0;
    //
    //	-- In conditional statements
    //	if a => b > c then
    //	  -- Do something when a is greater than b
    //	end if;
    //
    //	-- In signal assignments
    //	d <= a => b;
    //	```
    Arrow // =>

    // Plus is the plus token used to declare a plus operator in VHDL.
    //
    // The `+` operator is used to perform addition operations in VHDL. It can be used with various numeric types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : integer;
    // 	int_result := int_a + int_b;  -- int_result becomes 8
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : real;
    // 	real_result := real_a + real_b;  -- real_result becomes 6.2
    //
    // 	-- In conditional statements
    // 	if int_a + int_b > threshold then
    // 	  -- Do something when the sum is greater than threshold
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a + int_b;
    // 	```
    Plus
    // Minus is the minus token used to declare a minus operator in VHDL.
    //
    // The `-` operator is used to perform subtraction operations in VHDL. It can be used with various numeric types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : integer;
    // 	int_result := int_a - int_b;  -- int_result becomes 2
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : real;
    // 	real_result := real_a - real_b;  -- real_result becomes 1.2
    //
    // 	-- In conditional statements
    // 	if int_a - int_b < threshold then
    // 	  -- Do something when the difference is less than threshold
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a - int_b;
    // 	```
    Minus
    // Equal is the equal token used to declare an equal operator in VHDL.
    //
    // The `=` operator is used to perform equality comparisons in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : boolean;
    // 	int_result := int_a = int_b;  -- int_result becomes false
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : boolean;
    // 	real_result := real_a = real_b;  -- real_result becomes false
    //
    // 	-- In conditional statements
    // 	if int_a = int_b then
    // 	  -- Do something when the values are equal
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a = int_b;
    // 	```
    Equal
    // Star is the star token used to declare a star operator in VHDL.
    //
    // The `*` operator is used to perform multiplication operations in VHDL. It can be used with various numeric types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : integer;
    // 	int_result := int_a * int_b;  -- int_result becomes 15
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : real;
    // 	real_result := real_a * real_b;  -- real_result becomes 9.45
    //
    // 	-- In conditional statements
    // 	if int_a * int_b > threshold then
    // 	  -- Do something when the product is greater than threshold
    // 	end if;
    Star
    // StarStar is the star star token used to declare a star star operator
    // in VHDL.
    //
    // The `**` operator is used to perform exponentiation operations in VHDL. It can be used with various numeric types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : integer;
    // 	int_result := int_a ** int_b;  -- int_result becomes 125
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : real;
    // 	real_result := real_a ** real_b;  -- real_result becomes 29.44...
    //
    // 	-- In conditional statements
    // 	if int_a ** int_b > threshold then
    // 	  -- Do something when the product is greater than threshold
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a ** int_b;
    // 	```
    StarStar

    // GreaterThan is the greater than token used to declare a greater than
    // comparison operator in VHDL.
    //
    // The `>` operator is used to perform greater than comparisons in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : boolean;
    // 	int_result := int_a > int_b;  -- int_result becomes true
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : boolean;
    // 	real_result := real_a > real_b;  -- real_result becomes true
    //
    // 	-- In conditional statements
    // 	if int_a > int_b then
    // 	  -- Do something when int_a is greater than int_b
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a > int_b;
    // 	```
    GreaterThan
    // LessThan is the less than token used to declare a less than
    // comparison operator in VHDL.
    //
    // The `<` operator is used to perform less than comparisons in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : boolean;
    // 	int_result := int_a < int_b;  -- int_result becomes false
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : boolean;
    // 	real_result := real_a < real_b;  -- real_result becomes false
    //
    // 	-- In conditional statements
    // 	if int_a < int_b then
    // 	  -- Do something when int_a is less than int_b
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a < int_b;
    // 	```
    LessThan
    // Equals is the equals token used to declare an equals comparison
    // operator in VHDL.
    //
    // The `=` operator is used to perform equality comparisons in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : boolean;
    // 	int_result := int_a = int_b;  -- int_result becomes false
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : boolean;
    // 	real_result := real_a = real_b;  -- real_result becomes false
    //
    // 	-- In conditional statements
    // 	if int_a = int_b then
    // 	  -- Do something when the values are equal
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a = int_b;
    // 	```
    Equals
    // NotEqual is the not equal token used to declare a not equal comparison
    // operator in VHDL.
    //
    // The `/=` operator is used to perform not equal comparisons in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : boolean;
    // 	int_result := int_a /= int_b;  -- int_result becomes true
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : boolean;
    // 	real_result := real_a /= real_b;  -- real_result becomes true
    //
    // 	-- In conditional statements
    // 	if int_a /= int_b then
    // 	  -- Do something when the values are not equal
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a /= int_b;
    // 	```
    NotEqual
    // GreaterEqual is the greater equal token used to declare a greater
    // equal comparison operator in VHDL.
    //
    // The `>=` operator is used to perform greater than or equal to comparisons in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : boolean;
    // 	int_result := int_a >= int_b;  -- int_result becomes true
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : boolean;
    // 	real_result := real_a >= real_b;  -- real_result becomes true
    //
    // 	-- In conditional statements
    // 	if int_a >= int_b then
    // 	  -- Do something when int_a is greater than or equal to int_b
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a >= int_b;
    // 	```
    GreaterEqual
    // LessEqual is the less equal token used to declare a less equal
    // comparison operator in VHDL.
    //
    // The `<=` operator is used to perform less than or equal to comparisons in VHDL. It can be used with various types, including integers, floating-point numbers, and fixed-point types.
    //
    // Example:
    //
    //	```vhdl
    // 	-- For integer values
    // 	variable int_a : integer := 5;
    // 	variable int_b : integer := 3;
    // 	variable int_result : boolean;
    // 	int_result := int_a <= int_b;  -- int_result becomes false
    //
    // 	-- For real (floating-point) values
    // 	variable real_a : real := 3.5;
    // 	variable real_b : real := 2.7;
    // 	variable real_result : boolean;
    // 	real_result := real_a <= real_b;  -- real_result becomes false
    //
    // 	-- In conditional statements
    // 	if int_a <= int_b then
    // 	  -- Do something when int_a is less than or equal to int_b
    // 	end if;
    //
    // 	-- In signal assignments
    // 	output_signal <= int_a <= int_b;
    // 	```
    LessEqual
    // Out is the out token used to declare a port in VHDL.
    //
    // Example:
    //	```vhdl
    //	entity myentity is
    //		port (
    //			a : in bit;
    //			b : out bit
    //		);
    //	end myentity;
    //	```
    Out
    // Open is the open keyword used in VHDL.
    //
    // The open keyword is used in an association list (within a component
    // instantiation statement) to indicate a port that is not
    // connected to any signal.
    // Example:
    //	```vhdl
    //	U2: count8 port map (C => Clk1, Rst => Clr, L => Load, D => Data,
    // 		Q => , Cin => open);
    //	```
    Open
    // Buffer is one of five possible modes for an interface port. (The
    // other
    // four are in, out, inout, and linkage.)
    //
    // The buffer mode indicates a port which can be used for both input and
    // output, and it can have only one source.
    //
    // A buffer port can only be connected to another buffer port or to a signal
    // that also has only one source.
    // Example:
    //	```vhdl
    //	entity ent5 is
    // 	port (clk,reset : in std_logic;
    // 	p : buffer std_logic_vector(1 downto 0));
    // 	end ent5;
    //	```
    Buffer
    // InOut is the inout keyword used in VHDL.
    //
    // The inout keyword specifies one of five possible modes for an interface
    // port. (The other four are in, out, buffer, and linkage.)
    //
    // The inout mode indicates a port which can be used for both input and
    // output.
    //
    // Example:
    //	```vhdl
    //	library ieee;
    // 	use ieee.std_logic_1164.all;
    //
    // 	entity BidirBuffer is
    // 	  port (
    // 	    clk      : in  std_logic;
    // 	    enable   : in  std_logic;
    // 	    data_in  : in  std_logic_vector(7 downto 0);
    // 	    data_bus : inout std_logic_vector(7 downto 0);
    // 	    data_out : out std_logic_vector(7 downto 0)
    // 	  );
    // 	end BidirBuffer;
    //
    // 	architecture Behavioral of BidirBuffer is
    // 	begin
    // 	  process(clk)
    // 	  begin
    // 	    if rising_edge(clk) then
    // 	      if enable = '1' then
    // 	        -- Drive the bus with data_in when enable is active.
    // 	        data_bus <= data_in;
    // 	      else
    // 	        -- Put the bus in a high-impedance state when enable is not
    // active.
    // 	        data_bus <= (others => 'Z');
    // 	      end if;
    // 	    end if;
    // 	  end process;
    //
    // 	  process(clk)
    // 	  begin
    // 	    if rising_edge(clk) then
    // 	      data_out <= data_bus;
    // 	    end if;
    // 	  end process;
    // 	end Behavioral;
    //	```
    InOut
    // Linkage is the linkage keyword used in VHDL.
    //
    // The linkage keyword specifies one of five possible modes for an interface
    // port. (The other four are in, out, inout, and buffer.)
    //
    // The linkage mode indicates a port which can be used for both input and
    // output, and it can only correspond to a signal.
    //
    // Example:
    //	```vhdl
    //	library ieee;
    // 	use ieee.std_logic_1164.all;
    //
    // 	package SharedSignals is
    // 	  -- The linkage keyword indicates that this variable is not
    // 	  -- locally elaborated but rather linked externally.
    // 	  linkage variable global_signal : std_logic := '0';
    // 	end package SharedSignals;
    //
    // 	package body SharedSignals is
    // 	  -- No additional implementation is required for a linkage variable.
    // 	end package SharedSignals;
    //
    // 	------------------------------------------------------------------
    // 	-- Entity that Uses the Linkage Variable
    // 	------------------------------------------------------------------
    // 	entity LinkageExample is
    // 	  port (
    // 	    clk : in  std_logic;
    // 	    rst : in  std_logic
    // 	  );
    // 	end LinkageExample;
    //
    // 	architecture Behavioral of LinkageExample is
    // 	  -- Import the linkage variable from the package.
    // 	  use work.SharedSignals.all;
    // 	begin
    // 	  process(clk, rst)
    // 	  begin
    // 	    if rst = '1' then
    // 	      -- Reset the linked signal to '0'
    // 	      global_signal <= '0';
    // 	    elsif rising_edge(clk) then
    // 	      -- Toggle the global_signal each clock cycle.
    // 	      if global_signal = '0' then
    // 	        global_signal <= '1';
    // 	      else
    // 	        global_signal <= '0';
    // 	      end if;
    // 	      -- Report the current value of the linkage variable.
    // 	      report "global_signal is now: " & std_logic'image(global_signal);
    // 	    end if;
    // 	  end process;
    // 	end Behavioral;
    //	```
    Linkage
    // Dot represents the dot operator.
    Dot
    // All is the all token used to declare a generic map in
    //
    // In VHDL, the `all` keyword is typically used in two main contexts:
    //
    // 1. Package usage: When you want to import all elements from a package, you use the `all` keyword with the `use` clause:
    //
    // Example:
    //	```vhdl
    // 	use library_name.package_name.all;
    // 	```
    //
    // For example, to use all components from the standard logic package:
    //	```vhdl
    // 	use ieee.std_logic_1164.all;
    // 	```
    //
    // 2. Array indexing: The `all` keyword can be used to select all elements in an array simultaneously, particularly in signal assignments:
    //
    //	```vhdl
    // 	signal_array <= (others => '0');        -- Assigns '0' to all elements
    // 	signal_array(all) <= (others => '1');   -- Assigns '1' to all elements
    // 	```
    //
    // The `all` keyword helps simplify code by allowing you to reference multiple elements without explicitly listing each one individually.
    All
    // Alias is the alias token used to declare an alias in VHDL.
    //
    // The `alias` keyword allows you to create an alternative name (or alias) for an existing object, such as a signal, variable, constant, or even a portion of an object. This is useful for improving code readability, creating more intuitive names, or accessing specific parts of complex objects.
    //
    // Here's how the `alias` syntax works:
    //
    // Example:
    //	```vhdl
    // 	alias alias_name : subtype_indication is name;
    // 	```
    //
    // Some common use cases for `alias` include:
    //
    // 1. Creating a simpler name for a complex signal path:
    // Example:
    //	```vhdl
    // 	alias clock_signal is system_block.timing_unit.master_clock;
    // 	```
    //
    // 2. Renaming bits or slices of arrays or vectors:
    // Example:
    //	```vhdl
    // 	signal data_bus : std_logic_vector(31 downto 0);
    // 	alias address : std_logic_vector(15 downto 0) is data_bus(31 downto 16);
    // 	alias data : std_logic_vector(15 downto 0) is data_bus(15 downto 0);
    // 	```
    //
    // 3. Creating more meaningful names for function calls or operations:
    //
    // Example:
    //
    //	```vhdl
    // 	alias rising_edge is std.standard.rising_edge[std_logic return boolean];
    // 	```
    //
    // 4. Reverse range aliasing (changing array indexing direction):
    //
    //	```vhdl
    // 	signal data_down : std_logic_vector(7 downto 0);
    // 	alias data_up : std_logic_vector(0 to 7) is data_down;
    // 	```
    //
    // Aliases don't create new objects or consume additional hardware resources - they're simply alternative names that exist only during compilation.
    Alias
    // After is the after token used to declare an after clause in VHDL.
    //
    // Used to specify timing delays in signal assignments within simulation models.
    // It allows you to define how much simulation time should pass before a signal assignment takes effect.
    //
    // The `after` clause is primarily used in:
    //
    // 1. Signal assignment statements for simulation purposes:
    //
    // Example:
    //	```vhdl
    // 	clk <= '1' after 10 ns, '0' after 20 ns;
    // 	```
    //
    // 2. Multiple delayed assignments can be specified in a single statement:
    //	```vhdl
    // 	signal_name <= value1 after time1,
    // 	               value2 after time2,
    // 	               value3 after time3;
    // 	```
    //
    // For example, to create a clock signal:
    //	```vhdl
    // 	process
    // 	begin
    // 	  clock <= '0';
    // 	  wait for 5 ns;
    // 	  clock <= '1';
    // 	  wait for 5 ns;
    // 	end process;
    //
    // 	-- Alternatively using after:
    // 	clock <= '0', '1' after 5 ns, '0' after 10 ns, '1' after 15 ns;
    // 	```
    //
    // Important notes about the `after` keyword:
    // - It's only relevant during simulation and has no effect on synthesis
    // - Synthesis tools ignore `after` clauses when generating hardware
    // - It's commonly used for testbenches and timing verification
    // - Time expressions must be of a time type (fs, ps, ns, us, ms, sec, min, hr)
    //
    // The `after` keyword is essential for creating realistic timing simulations and properly testing VHDL designs before synthesis.
    After
    // Access is a type of access to a signal.
    // TODO: add more information about access types
    Access
)
```

<a name="EOF"></a>EOF is the end of file token/rune.

```go
const EOF TokenType = -1
```

<a name="TokenType.MarshalJSON"></a>
### func \(TokenType\) [MarshalJSON](<https://github.com/conneroisu/gohard/blob/main/internal/vhdl/tokens/tokens.go#L137>)

```go
func (typ TokenType) MarshalJSON() ([]byte, error)
```

MarshalJSON implements the json.Marshaler interface.

<a name="TokenType.String"></a>
### func \(TokenType\) [String](<https://github.com/conneroisu/gohard/blob/main/internal/vhdl/tokens/tokentype_string.go#L153>)

```go
func (i TokenType) String() string
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->
