package twerge

import (
	"fmt"
	"strings"

	"maps"

	"github.com/dave/jennifer/jen"
)

// classMap is a mapping of original class strings to generated class names
type classMap map[string]string

var (
	// cache for generated classes
	genCache = newCache(1000)
)

// It returns a short unique CSS class name from the merged classes.
//
// If the class name already exists, it will return the existing class name.
//
// If the class name does not exist, it will generate a new class name and return it.
func It(classes string) string {
	if className, exists := ClassMapStr[classes]; exists {
		return className
	}
	// First check if a class name exists in ClassMapStr
	mapMutex.RLock()
	if className, exists := ClassMapStr[classes]; exists {
		mapMutex.RUnlock()
		return className
	}
	mapMutex.RUnlock()

	// First, merge the classes
	merged := Merge(classes)

	// Store the mapping
	mapMutex.Lock()
	classname := fmt.Sprintf("tw-%d", classID)
	ClassMapStr[classes] = classname
	GenClassMergeStr[classname] = merged
	genCache.Set(merged, classname)
	classID++
	mapMutex.Unlock()

	return classname
}

func getMapping() classMap {
	mapMutex.RLock()
	defer mapMutex.RUnlock()

	// Create a copy to avoid concurrent map access issues
	mapping := make(classMap, len(ClassMapStr))
	maps.Copy(mapping, ClassMapStr)

	return mapping
}

// GenerateClassMapCode generates Go code for a variable containing the class mapping
func GenerateClassMapCode(packageName string) string {
	mapping := getMapping()

	// Create a new file
	f := jen.NewFile(packageName)

	// Add a package comment
	f.PackageComment("Code generated by twerge. DO NOT EDIT.")

	// Create the ClassMapStr variable
	f.Var().Id("ClassMapStr").Op("=").Map(jen.String()).String().Values(jen.DictFunc(func(d jen.Dict) {
		// Sort keys for deterministic output
		var keys []string
		for k := range mapping {
			keys = append(keys, k)
		}

		// Add each key-value pair
		for _, k := range keys {
			d[jen.Lit(k)] = jen.Lit(mapping[k])
		}
	}))

	// Generate the code
	buf := &strings.Builder{}
	err := f.Render(buf)
	if err != nil {
		return "// Error generating code: " + err.Error()
	}

	return buf.String()
}
