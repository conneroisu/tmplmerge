package twerge

import (
	"crypto/md5"
	"encoding/base64"
	"strings"

	"maps"

	"github.com/dave/jennifer/jen"
)

// classMap is a mapping of original class strings to generated class names
type classMap map[string]string

var (
	// cache for generated classes
	genCache = newCache(1000)
)

// Generate creates a short unique CSS class name from the merged classes
func Generate(classes string) string {
	// First check if a class name exists in ClassMapStr
	mapMutex.RLock()
	if className, exists := ClassMapStr[classes]; exists {
		mapMutex.RUnlock()
		return className
	}
	mapMutex.RUnlock()

	// First, merge the classes
	merged := Merge(classes)

	// Check if we've already generated a class for this set of merged classes
	mapMutex.RLock()
	if cachedClass := genCache.Get(merged); cachedClass != "" {
		mapMutex.RUnlock()
		return cachedClass
	}
	mapMutex.RUnlock()

	// Generate a hash of the merged classes
	hash := md5.Sum([]byte(merged))

	// Use URL-safe base64 encoding and trim to 7 characters for brevity
	encoded := base64.URLEncoding.EncodeToString(hash[:])
	classname := "tw-" + encoded[:7]

	// Store the mapping
	mapMutex.Lock()
	ClassMapStr[classes] = classname
	genCache.Set(merged, classname)
	mapMutex.Unlock()

	return classname
}

func getMapping() classMap {
	mapMutex.RLock()
	defer mapMutex.RUnlock()

	// Create a copy to avoid concurrent map access issues
	mapping := make(classMap, len(ClassMapStr))
	maps.Copy(mapping, ClassMapStr)

	return mapping
}

// GenerateClassMapCode generates Go code for a variable containing the class mapping
func GenerateClassMapCode(packageName string) string {
	mapping := getMapping()

	// Create a new file
	f := jen.NewFile(packageName)

	// Add a package comment
	f.PackageComment("Code generated by twerge. DO NOT EDIT.")

	// Create the ClassMapStr variable
	f.Var().Id("ClassMapStr").Op("=").Map(jen.String()).String().Values(jen.DictFunc(func(d jen.Dict) {
		// Sort keys for deterministic output
		var keys []string
		for k := range mapping {
			keys = append(keys, k)
		}

		// Add each key-value pair
		for _, k := range keys {
			d[jen.Lit(k)] = jen.Lit(mapping[k])
		}
	}))

	// Generate the code
	buf := &strings.Builder{}
	err := f.Render(buf)
	if err != nil {
		return "// Error generating code: " + err.Error()
	}

	return buf.String()
}
